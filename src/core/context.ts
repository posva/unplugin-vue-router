import chokidar from 'chokidar'
import { Options } from '../options'
import { createPrefixTree } from './tree'
import { promises as fs } from 'fs'
import { logTree, throttle } from './utils'
import { generateRouteNamedMap } from '../codegen/generateRouteMap'
import { MODULE_ROUTES_PATH, MODULE_VUE_ROUTER } from './moduleConstants'
import { generateRouteRecord } from '../codegen/generateRouteRecords'
import fg from 'fast-glob'
import { resolve } from 'pathe'

export function createRoutesContext(options: Required<Options>) {
  const { dts: preferDTS, root } = options
  const dts =
    preferDTS === false
      ? false
      : preferDTS === true
      ? resolve(root, 'typed-router.d.ts')
      : resolve(root, preferDTS)

  const routeTree = createPrefixTree(options)

  function log(...args: any[]) {
    if (options.logs) {
      console.log(...args)
    }
  }

  const resolvedRoutesFolder = resolve(root, options.routesFolder)
  const serverWatcher = chokidar.watch(resolvedRoutesFolder, {
    ignoreInitial: true,
    disableGlobbing: true,
    ignorePermissionErrors: true,
    // useFsEvents: true,
    // TODO: allow user options
  })

  function stripRouteFolder(path: string) {
    return path.slice(resolvedRoutesFolder.length + 1)
  }

  async function scanPages() {
    const routeFolders: string[] = [resolvedRoutesFolder]
    const pattern = `**/*.{${options.extensions
      .map((extension) => extension.replace('.', ''))
      .join(',')}}`
    const files = (
      await Promise.all(
        routeFolders.map((folder) =>
          fg(pattern, { cwd: folder, followSymbolicLinks: true }).then(
            (files) => files.flatMap((file) => resolve(folder, file))
          )
        )
      )
    ).flat()
    // TODO: filter out excluded files

    for (const file of files) {
      addPage(file)
    }
    await _writeConfigFiles()
  }

  function addPage(path: string) {
    log('added', path)
    const route = stripRouteFolder(path)
    // TODO: handle top level named view HMR
    routeTree.insert(
      route,
      // './' + path
      resolve(root, path)
    )
  }

  function removePage(path: string) {
    log('remove', path)
    routeTree.remove(stripRouteFolder(path))
  }

  function setupWatcher() {
    serverWatcher
      .on('change', (path) => {
        // TODO: parse defineRoute macro?
        log('change', path)
        writeConfigFiles()
      })
      .on('add', (path) => {
        addPage(path)
        writeConfigFiles()
      })
      .on('unlink', (path) => {
        removePage(path)
        writeConfigFiles()
      })
  }

  function generateRoutes() {
    return `export const routes = ${generateRouteRecord(routeTree)}`
  }

  function generateDTS(): string {
    return `
// Generated by unplugin-vue-router. ‼️ DO NOT MODIFY THIS FILE ‼️
// It's recommended to commit this file.
// Make sure to add this file to your tsconfig.json file as an "includes" or "files" entry.

/// <reference types="unplugin-vue-router/client" />

import type {
  _RouterTyped,
  RouteRecordInfo,
  RouterLinkTyped,
  RouteLocationNormalizedLoadedTypedList,
  RouteLocationAsString,
  NavigationGuard,
  _ParamValue,
  _ParamValueOneOrMore,
  _ParamValueZeroOrMore,
  _ParamValueZeroOrOne,
} from 'unplugin-vue-router'

declare module '${MODULE_ROUTES_PATH}' {
${generateRouteNamedMap(routeTree)
  .split('\n')
  .filter((line) => line)
  .map((line) => '  ' + line) // not the same as padStart(2)
  .join('\n')}
}

declare module '${MODULE_VUE_ROUTER}' {
  import type { RouteNamedMap } from '${MODULE_ROUTES_PATH}'

  export type RouterTyped = _RouterTyped<RouteNamedMap>
  /**
   * Generate a type safe route location. Requires the name of the route to be passed as a generic.
   */
  export type Route<Name extends keyof RouteNamedMap> = RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[Name]
  /**
   * Generate a type safe params for a route location. Requires the name of the route to be passed as a generic.
   */
  export type RouteParams<Name extends keyof RouteNamedMap> = RouteNamedMap[Name]['params']
  /**
   * Generate a type safe raw params for a route location. Requires the name of the route to be passed as a generic.
   */
  export type RouteParamsRaw<Name extends keyof RouteNamedMap> = RouteNamedMap[Name]['paramsRaw']

  export function useRouter(): RouterTyped
  export function useRoute<Name extends keyof RouteNamedMap = keyof RouteNamedMap>(name?: Name): RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[Name]

  export function onBeforeRouteLeave(guard: NavigationGuard<RouteNamedMap>): void
  export function onBeforeRouteUpdate(guard: NavigationGuard<RouteNamedMap>): void
}

declare module '@vue/runtime-core' {
  import type { RouteNamedMap } from '${MODULE_ROUTES_PATH}'

  export interface ComponentCustomOptions {
    beforeRouteUpdate?: NavigationGuard<RouteNamedMap>
    beforeRouteLeave?: NavigationGuard<RouteNamedMap>
  }

  export interface ComponentCustomProperties {
    $route: RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[keyof RouteNamedMap]
    $router: _RouterTyped<RouteNamedMap>
  }

  export interface GlobalComponents {
    RouterLink: RouterLinkTyped<RouteNamedMap>
  }
}
`
  }

  // NOTE: this code needs to be generated because otherwise it doesn't go through transforms and `@vue-router/routes`
  // cannot be resolved.
  function generateVueRouterProxy() {
    return `
import { routes } from '@vue-router/routes'
import { createRouter as _createRouter } from 'vue-router'

export * from 'vue-router'

export function createRouter(options) {
  const { extendRoutes } = options
  if (typeof extendRoutes === 'function') {
    routes = extendRoutes(routes) || routes
  }

  return _createRouter({
    ...options,
    routes,
  })
}
`
  }

  let lastDTS: string | undefined
  async function _writeConfigFiles() {
    log('writing')
    logTree(routeTree, log)
    if (dts) {
      const content = generateDTS()
      if (lastDTS !== content) {
        await fs.writeFile(dts, content, 'utf-8')
        lastDTS = content
      }
    }
  }

  // debounce of 100ms + throttle of 500ms
  // => Initially wait 100ms (renames are actually remove and add but we rather write once) (debounce)
  // subsequent calls after the first execution will wait 500ms-100ms to execute (throttling)
  const writeConfigFiles = throttle(_writeConfigFiles, 500, 100)

  setupWatcher()

  function stopWatcher() {
    serverWatcher.close()
  }

  return {
    scanPages,
    writeConfigFiles,

    stopWatcher,

    generateRoutes,
    generateVueRouterProxy,
  }
}
